Â¿QuÃ© es la Poo?

La Poo es una paradigma que nos permite mapear objetos reales al mundo digital. ğŸš€

ğŸ¤”Â¿QuÃ© es una clase?

Una clase es una un â€œMoldeâ€ para crear objetos, la cual esta compuesta por atributos y mÃ©todos. ğŸ˜¯

ğŸ”³Â¿QuÃ© es un objeto?

Son entidades que tienen un determinado estado, comportamiento e identidad.ğŸ˜
Es el resultado de la instancia de una clase.

ğŸ˜§Â¿A que se refieren con instancia?

Se refiere a la actividad de crear un objeto mediante la lectura, recuperaciÃ³n de los atributos de una clase.ğŸ¤©

IntroducciÃ³n a clases y objetos
La clase es el molde con el cual crearemos nuestros objetos. 
Para crear una clase y despuÃ©s un objeto lo hacemos asÃ­:

<?php

class User {
    public $type;
}

class Admin {
    public function greet() {
        return "Hola admin";
    }
}

$user = new User;
$user->type = new Admin;
echo $user->type->greet();


Y despuÃ©s partirlos en mÃ³dulos:

index.php
<?php

require_once './person.php';
require_once './user.php';
require_once './admin.php';

$usuario = new User;
$usuario->type = new Admin;
echo $usuario->type->greet();

person.php
<?php

class Person {
    public function greet() {
        return "Hola $this->name";
    }
}

user.php
<?php

class User {
    public $type;
}

admin.php
<?php

class Admin extends Person {
    public $name = 'Administrador';
}

Una definiciÃ³n mÃ¡s sencilla es: â€œAbstracciÃ³n es simplemente crear una plantilla de la clase que queremos crearâ€ es eso, una plantilla, porque al implementarla nos vemos obligados a respetar esa plantilla.

Un caso prÃ¡ctico para los mÃ©todos abstractos es cuando quieres tener una clase que va a ser heredada por otras dos clases, y esas dos clases van a tener una funciÃ³n con nombre similar, pero que van a realizar acciones completamente distintas, por ende, no puedes definir las instrucciones en la clase padre, pero necesitas definir algo, en ese caso usas un mÃ©todo abstracto, es decir, una plantilla del mÃ©todo que posteriormente serÃ¡ definido en las clases hijas.

Se que es complicado de entender, pero realizando prÃ¡cticas y echÃ¡ndole cabeza se logra comprender ğŸ˜„!

//Public
: Es una propiedad publica, a la cual puedo acceder desde cualquier parte de mi cÃ³digo y puedo modificarla sin problemas:

<?php

class User {

    public $name;
    
}

$pablito = new User;
$pablito->name = "Pablito";

?>
Esto es posible porque $name es una propiedad publica, por tanto, puedo acceder desde fuera de la clase, la clase abarca desde la llave de apertura hasta la llave de cierre de la clase.

//Protected
: Esta propiedad es exclusiva de PHP, basicamente, hace que esta propiedad NO pueda ser accedida desde fuera de mi clase, pero SI puede ser accedida desde cualquier otra clase que herede a mi clase, Â¿QuÃ© es herencia? No te preocupes, ya casi llegamos a ese tema, pero que el nombre te vaya dando una idea, por tanto, este ejemplo:

<?php

class User {

protected $name;
}

$pablito = new User;
$pablito->name = â€œPablitoâ€;

?>
MandarÃ­a un error, pues $name es protected y no puedo llamarla desde fuera de la clase, pero este otro ejemplo:

<?php

class User {

    protected $name;
    
}

class Pablito extends User{

    public function poner_nombre($nombre){
        $this->name = $nombre;
    }

}


$pablito = new Pablito;
$pablito->poner_nombre("Pablito");

?>
Si funcionarÃ­a, pues las clases que heredan de mi clase SI pueden acceder.

//Private: 
Este nos indica que nada, absolutamente nada que NO estÃ© dentro de mi clase va a poder acceder a esa propiedad o mÃ©todo, ni aunque la heredes, esa propiedad va a estar disponible Ãºnica y estrictamente dentro de mi clase, por lo que el ejemplo anterior darÃ­a error (Si hubiÃ©semos puesto private $name), pero el siguiente ejemplo funcionarÃ­a a la perfecciÃ³n:

<?php

class User {

    private $name;

    public function poner_nombre($nombre) {
        $this->name = $nombre;
    }
    
}

$pablito = new User;
$pablito->poner_nombre("Pablito");

?>

//Modularidad
Esta no es una tÃ©cnica de programaciÃ³n, pero si es algo con lo que debemos cumplir para que a futuro se mÃ¡s fÃ¡cil la mantenibilidad. Este concepto aplica views, models, controllers, helpers, etc.

âš  Debemos pensar en mÃ³dulos, no en un solo archivo con todo el cÃ³digo.

Este hace referencia a tener pequeÃ±os archivos que al unirlos forman el sistema en si.

La modularidad es la base del buen cÃ³digo, es de lo que venimos hablando siempre, divide todo, se lo mÃ¡s especÃ­fico posible y siempre tendrÃ¡s un cÃ³digo mejor organizado, mantenible y fÃ¡cil de entender.

//Polimorfismo
El polimorfismo solamente significa varias formas. Esto quiere decir que si un mismo elemento si se comporta de diferentes maneras y otorga diferentes resultados quiere decir que aplica el tÃ©rmino de polimorfismo.

<?php

abstract class Base {
    protected $name;

    private function getClassName() {
        return get_called_class();
    }

    public function login() {
        return "<p>Mi nombre es $this->name desde la clase {$this->getClassName()} <br><p>";
    }
}

class Admin extends Base {
    public function __construct($name) {
        $this->name = $name;
    }
}

class User extends Base {
    public function __construct($name) {
        $this->name = $name;
    }
}

class Guest extends Base {
    protected $name = 'invitado';
}

$guest = new Guest();
echo $guest->login();

$admin = new Admin('Helena');
echo $admin->login();

$user = new User('John Moore');
echo $user->login();

Para abrir el servidor de php utilizamos el comando

php -S localhost:8000
Y tambiÃ©n podemos ejecutar el archivo utilizando el comando:

php *archivo*.php

Polimorfismo: interfaz
En programaciÃ³n avanzada siempre vamos a trabajar sobre interfaces. Vamos a trabajar con estas porque es lo que enviamos, o sea, que lo enviamos a nivel de configuraciÃ³n.

Nos vamos a encargar de preparar todo el cÃ³digo necesario, asÃ­ no trabajamos sobre _usuarios _sino sobre la interfaz de usuarios.

index.php

<?php

require_once "./user.php";
require_once "./post.php";

$user = new User();
echo $user->all();

$post = new Post();
echo $post->all();
search_interface.php
<?php

interface Search {
    public function all();
}
user.php
<?php

require_once "./search_interface.php";

class User implements Search {
    public function all() {
        return "Obteniendo a los Usuarios";
    }
}
post.php
<?php

require_once "./search_interface.php";

class Post implements Search {
    public function all() {
        return "Obteniendo a los Post";
    }
}
//POLIMORFISMO 
Polimorfismo: interfaz
En programaciÃ³n avanzada siempre vamos a trabajar sobre interfaces. Vamos a trabajar con estas porque es lo que enviamos, o sea, que lo enviamos a nivel de configuraciÃ³n.

Nos vamos a encargar de preparar todo el cÃ³digo necesario, asÃ­ no trabajamos sobre _usuarios _sino sobre la interfaz de usuarios.
Una interfaz se puede usar para crear diferentes mÃ©todos que se comporten de maneras distintas, pero esta sirve como plantilla, y sin querer queriendo ya estamos trabajando usando polimorfismo.

El concepto de Herencia no hace que se puede â€œheredar por heredarâ€, o â€œporque algunos mÃ©todos me sirve y reutilizoâ€, tiene que tener un sentido, tiene que ser de la familia", debe cumplir como ES-UN", como por ejemplo:
Gato es un Animal? Si
Caballo es un Animal? Si
Auto en un VehÃ­culo? Si
Tren es un vehÃ­culo? Si
Caballo es un vehÃ­culo? Hemm, si, a tracciÃ³n a sangre. Es una Animal pero tambiÃ©n puede ser un VehÃ­culo, comparte solamente comportamiento para trasladar.

Ahora imaginemos que tenemos a una persona que le debemos pasar un vehÃ­culo para que pueda viajar.
Si tenemos a Auto y a Tren que heredan de VehÃ­culo, podemos pasarle a Persona el objeto VehÃ­culo, sea auto o tren o los que hereden (porque tambiÃ©n serÃ­a como un contrato)

classPersona{
    publicfunctionviajar(Vehiculo $vehiculo){
        return $vehiculo->transportar();
    }
}

classVehiculo{
    public $nombre;

    publicfunctiontransportar(){
        return"Voy en " . $this->nombre;
    }
}

classAutomovilextendsVehiculo{
    public $nombre = "Auto";    
}

classTrenextendsVehiculo{
    public $nombre = "Tren";    
}

$auto = new Automovil();
$tren = new Tren();

$pasajero = new Persona();
echo $pasajero->viajar($auto);

Pero tambiÃ©n podemos pasarle un Caballo, pero supongamos que Caballo y Gato ya heredan de Animal y PHP no acepta herencia mÃºltiple (tampoco tendrÃ­a sentido herencia entre tipos de vehiculos y animales).

Entonces puedo crear una Interface Transporte para que los Vehiculos implementen un mÃ©todo transportar()

InterfaceTransporte{
    publicfunctiontransportar();
}
La clase Persona me quedarÃ­a con un mÃ©todo que acepte ese contrato Transporte

class Persona {
    public function viajar(Transporte $vehiculo) {
        return $vehiculo->transportar();
    }
}
A la supercale Vehiculo le implemento la interface Transporte y por lo tanto las subclases tambiÃ©n van a ser de tipo Transporte y van a cumplir el contrato. (si tenemos vehÃ­culos que en el sistema no sirvan como transporte (como en el caso de los animales) pordemos implementar la interface solamente en las clases especÃ­ficas, pero en este caso todo los vehÃ­culo quiero que sean Transporte)

classVehiculoimplementsTransporte{
    public $nombre;

    publicfunctiontransportar(){
        return"Voy en " . $this->nombre;
    }
}
La clase Caballo implementa la interface Transporte y ya cumple el contrato para poder pasarlo a la persona que quiere este tipo de Transporte, pero solamente Caballo, continÃºa siendo de Tipo Animal como tambiÃ©n lo es Gato, pero gato no es Trasporte porque no implementa la interface Transporte

classAnimal{
    public $nombre;
}

classGatoextendsAnimal{
    public $nombre = "Gato";
}

classCaballoextendsAnimalimplementsTransporte{
    public $nombre = "Caballo"; 

    public function transportar() {
        return"Voy en " . $this->nombre;
    }
}
Ahora podemos pasarle a Persona cualquier objeto de VehÃ­culo y Caballo, porque pide que cumpla el contrato de Transporte

$caballo = new Caballo();

$pasajero = new Persona();
echo $pasajero->viajar($caballo);

una interfaz es simplemente un contrato, es algo que te asegura que, cualquier clase que implemente esa interfaz sÃ­ o sÃ­ van a tener los mÃ©todos que esa interfaz expone.

A la interfaz no le importa cÃ³mo se comporte el mÃ©todo, a la interfaz le importa que cualquier clase que la use, sÃ­ o sÃ­ tenga ese mÃ©todo.

Â¿Esto para quÃ© sirve? Bueno, imaginamos que ahora tienes una clase B, y la clase B tiene un mÃ©todo que recibe por parÃ¡metro una instancia de cualquier clase. Esto se llama inyecciÃ³n de dependencias y es parte de los principios SOLID y se usa mucho en PHP.

Entonces, como tÃº esperas que se te pase por parÃ¡metro la instancia de una clase, tÃº puedes simplemente usar esa instancia y acceder a sus mÃ©todos:

classPersona{
	publicfunctionsaludar(){
		echo"Hola :D";
	}
}

classSaludo{
	publicfunctionhacerSaludo($instancia){
		$instancia->saludar();
	}
}

$saludo = new Saludo();
$persona = new Persona();

$saludo->hacerSaludo($persona);
De esta forma, la clase Saludo tiene un mÃ©todo que recibe una instancia de cualquier otra clase, y este mÃ©todo, sin saber si existe o si no existe el mÃ©todo saludar en esa instancia que se le pasÃ³, lo manda a llamar, y si no existe entonces va a provocar un error.

AquÃ­ es donde las interfaces entran en juego, puedes usar una interfaz para esperar que cualquier clase que se te pase por ahÃ­ tenga sÃ­ o sÃ­ el mÃ©todo que tÃº quieres, sabes que la interfaz te va a garantizar que ese mÃ©todo sÃ­ va a existir cuando se te pase una instancia y que no se te pueda pasar ninguna instancia que no implemente a dicha interfaz:

interfacetienesQueSaludar{
	publicfunctionsaludar();
}

classPersonaimplementstienesQueSaludar{
	
	/* Ahora estÃ¡ obligado a implementarlo */
	publicfunctionsaludar(){
		echo"Hola :D";
	}

}

classSaludo{

	/* AquÃ­ le digo que si la clase no implementa a la interfaz, entonces no puede pasar, asÃ­ me aseguro que sÃ­ o sÃ­ puedo usar el mÃ©todo saludar, porque sÃ© que esa interfaz me lo asegura */
	publicfunctionhacerSaludo(tienesQueSaludar $instancia){
		$instancia->saludar();
	}

}

$saludo = new Saludo();
$persona = new Persona();

$saludo->hacerSaludo($persona);
Para eso sirven las interfaces, te digo, todo esto hace referencia a los principios SOLID, en este caso se hace especial referencia al principio de inyecciÃ³n de dependencias

Herencia
La herencia nos permitirÃ¡ crear nuevas clases a partir de otras. O sea, vamos reutilizar cÃ³digo. Quiere decir, que vamos a hacer una abstracciÃ³n para generar una sÃºper clases general que despuÃ©s utilicemos para crear otras clases.

En la herencia tambiÃ©n tendremos una jerarquÃ­a de padre e hijo.
En OOP, la clase padre siempre la encontraremos como la â€˜SÃºperclaseâ€™ y los hijos como â€˜subclaseâ€™.
Y a travÃ©s de encapsulamiento vamos a poder definir que puede heredar el hijo y que no.

El mÃ©todo constructor nos permite inicializar las variables del objeto.

<?php

class User {
    public $name;

    public function __construct($name) {
        $this->name = $name;
    }
}
Y para crear una herencia utilizamos la palabra reservada extends seguido del nombre de la clases.

<?php

class Admin extends User {
    // ...
}
Para evitar que se incumpla los principios SOLID 2 y 3, podemos utilizar la palabra reservada final al principio del mÃ©todo. TambiÃ©n, podemos utilizar este la palabra reservado final en una clase, pero esto significa que no puede ser heredada.

<?php

class User {
    public $name;

    final public function __construct($name) {
        $this->name = $name;
    }
}

//Interfaces (clases)
una interface es un elemento de â€œAnÃ¡lisis Orientado a Objetros (por cierto, deberÃ­a haber un curso de esto antes de POO para entender bien este mundo)â€ donde lo que se busca es romper dependencias estrictas de un objeto X con un objeto Y y ser mÃ¡s flexibles. Esto lo van a ver mucho cuando empiecen a trabajar en proyectos complejos. Voy a tratar de hacer un ejemplo:

Supongamos que tienes una empresa de transporte y tienes una flota de taxis y personas que solicitan el servicio:

<?php

class Taxi
{
    public $matricula;

    public function __construct($matricula)
    {
        $this->matricula = $matricula;
    }
    
    public function viajar($inicio, $destino)
    {
        return "Se ha trasladado desde $inicio hasta $destino";
    }

}


class Person 
{
    public $name;

    public function __construct($name)
    {
        $this->name = $name;
    }

    public function solicitarTraslado(Taxi $taxi, $lugarInicio, $lugarDestino)    
    {
        echo "$this->name ha solicitado servicio de traslado del vehÃ­culo $taxi->matricula</br>";
        echo $taxi->viajar($lugarInicio, $lugarDestino);
    }
}

$taxi = new Taxi("ABC123");
$persona = new Person("JosÃ©");
$persona->solicitarTraslado($taxi,"Av Fuerzas Armadas", "Av Baralt");
Ahora imaginen que te fue muy bien en tu negocio y no solo tienes taxis, ahora tienes aviones, trenes, barcos (Wao!!! adoptame!! jejeje)â€¦ Bueno deben modificar su sistema porque ahora el cliente puede solicitar un traslado en cualquier tipo de transporte que tengamos. Si ven, aquÃ­ tenemos una dependencia estricta de dos objetos:

class Person 
{
    public $name;

    public function__construct($name)
    {
        $this->name= $name;
    }

    public function solicitarTransporte(Taxi $taxi (AQUÃ!!!!),
 $lugarInicio, $lugarDestino)    
    {
        echo "$this->name he solicitado servicio de traslado del vehÃ­culo $taxi->matricula</br>";
        echo $taxi->viajar($lugarInicio, $lugarDestino);
    }
}
La persona solo puede solicitar traslado en taxi y queremos que pueda solicitar traslado en lo que tengamos. AquÃ­ es donde entra la INTERFACE

Quiero que cualquier persona pueda trasladarse en los tipos de vehÃ­culos disponibles (taxi, barco y tren. PrÃ³ximamente en unidades de spaceX jajajajaja). DeberÃ­amos hacer esta implementaciÃ³n:

interface Transporte
{
    public function viajar($inicio, $destino);
}


class Taxi implements Transporte
{
    public $matricula;

    public $type = 'Taxi';

    public function __construct($matricula)
    {
        $this->matricula = $matricula;
    }
    
    public function viajar($inicio, $destino)
    {
        return "Se ha trasladado en el $this->type desde $inicio hasta $destino";
    }
}

class Barco implements Transporte
{
    public $matricula;

    public $type = 'Barco';

    public function __construct($matricula)
    {
        $this->matricula = $matricula;
    }
    
    public function viajar($inicio, $destino)
    {
        return "Se ha trasladado $this->type desde $inicio hasta $destino";
    }
}


class Tren implements Transporte
{
    public $matricula;

    public $type = 'Tren';

    public function __construct($matricula)
    {
        $this->matricula = $matricula;
    }
    
    public function viajar($inicio, $destino)
    {
        return "Se ha trasladado $this->type desde $inicio hasta $destino";
    }
}


class Person 
{
    public $name;

    public function __construct($name)
    {
        $this->name= $name;
    }

    public function solicitarTraslado(Transporte $transporte, $lugarInicio, $lugarDestino)    
    {
        echo "$this->name he solicitado servicio de traslado del vehÃ­culo $transporte->matricula</br>";
        echo $transporte->viajar($lugarInicio, $lugarDestino).'<hr>';
    }
}

$taxi = new Taxi("ABC123");
$persona = new Person("JosÃ©");
$persona->solicitarTraslado($taxi,"Av Fuerzas Armadas", "Av Baralt");

$barco = new Barco("DEF456");
$persona = new Person("MarÃ­a");
$persona->solicitarTraslado($barco,"Av Fuerzas Armadas", "Av Baralt");

$tren = new Tren("XXX654");
$persona = new Person("Pablo");
$persona->solicitarTraslado($tren,"Av Fuerzas Armadas", "Av Baralt");
Si ven ahora lo que se le pasa a la clase Person es un objeto de tipo Transporte. AsÃ­ rompemos la dependencia estricta de mi sistema que solo podÃ­a ofrecer traslados en taxi. Ahora a facturar mÃ¡s!!!

Espero este ejemplo haya aclarado el uso de las interfaces.